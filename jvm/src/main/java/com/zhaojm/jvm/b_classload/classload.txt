a. 加载  == > 生成 class 文件
1. 通过一个类的全限定名获取定义此类的二进制字节流
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3.在内存中商城一个代表这个类的java.lang.Class 对象，作为方法区这个类各种访问数据的访问入口。

b.链接
1.验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机操作妖气，保证被加载类的正确性，不会危害虚拟机自身安全。文件格式验证，元数据验证，字节码验证，符号引用验证。
2.准备：为变量分配内存并且设置该类变量的默认初始值，及零值。这里不包含 final 修饰的 static ，因为 final 在编译时候就会分配了，准备阶段和显示初始化；这里不会为实例化变量初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到 java 堆中。
3.解析：将常量池类的符号引用转化为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。

c.初始化
1. 初始化阶段就是执行类构造器方法<clinit>()的过程。
2. 此方法不需要定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
3. 构造器方法中指令按语句在源文件中出现的顺序执行。
4. <clinit>() 不同于类的构造器。
5. 若该类具有父类，JVM 会保证子类的<clinit>() 执行前，父类的<clinit>() 已经执行完毕。
6. 虚拟机必须保证一个类的<clinit>() 方法在多线程下ebz同步加锁。



a. 启动类加载器（引导类加载器，Bootstrap ClassLoader）
    1. 这个类加载使用C/C++语言实现，嵌套在JVM 内部。
    2. 它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或者sum.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类。
    3. 并不继承自 java.lang.ClassLoader，没有父类加载器。
    4. 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
    5. 处于安然考虑， Bootstrap 类加载器只加载报名为 java、javax、sum 等开头的类。




